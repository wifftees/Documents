#import "../template/paper_template.typ": paper
#show: doc => paper(
  font: "Computer Modern", // "Times New Roman"
  // fontsize: 12pt, // 12pt
  title: [Задачи третей трети семестра], // title someone one
  authors: (
    (
      name: "Бугрий Илья",  
      affiliation: "M3134",
      email: "",
      note: "",
    ),
  ),
  date: "08.01.2024",
  keywords: [],
  acknowledgements: "", // Acknowledgements 
  bibloc: "My Library.bib",
  // bibstyle: "chicago-author-date", // ieee, chicago-author-date, apa, mla
  // bibtitle: "References",
  doc,
)
// your main text goes here
#set heading(numbering: "1.")
#set text(spacing: 100%)
#set par(leading: 1.5em)
#set par(
  first-line-indent: 2em,
  justify: true,
)

= Задачи третей трети семестра
#v(1cm)
  
#set enum(numbering: "1.a)")
+ 
  - Любой $P_i in {P_i (x_1 ... x_n)}^n_(i=1)$ однозначно задается набором коэффициентов, 
  который можно представить в виде вектора $xi$ из арифметического векторного \
  пространства $F$ $ xi = mat(xi_1; xi_2; dots.v; xi_n) $
  - Преобразование $P_i (x) arrow accent(P_i, tilde.basic)(x) arrow.l.r.long.double xi
   arrow tilde(xi) =>$ все преобразования существующие на данных полиномах, должны существовать на векторах в арифметическом векторном пространстве $=>$ мы можем только: 
   - Прибавлять к вектору (полиному) другой вектор (полином) $xi + xi^'$ \
   - Умножать вектор (полином) на скаляр $lambda xi$
  - Рассмотрим умножение на скаляр: $tilde(P_i)(x) = lambda dot P_i (x)$
  $ 
    forall x in U: tilde(P_i) (x) = lambda dot P_i (x) = lambda dot 0 = 0 => "инвариантность сохраняется" 
  $
  - Рассмотрим сложение с вектором, который однозначно задает \ 
    полином $P_j in {P_i (x_1 ... x_n)}^n_(i=1)$
  $
    forall x in U: tilde(P_i) (x) = P_j (x) + P_i (x) = 0 + 0 = 0 => "инвариантность сохраняется"
  $
  - Пусть $X = {P_i (x_1 ... x_n)}^n_(i=1)$ 
  - По определению $ P(x) = sum_(i = 1)^n xi_i x_i   $
  - Пусть $ M = {xi in F | forall x in U: sum_(i = 1)^n xi_i x_i = 0 } $
  - Определим $phi$ как функцию, которая по полиному дает его коэффиценты в $F$, тогда
  $
    phi(X) subset.eq M
  $

  - Рассмотрим преобразование из $xi^'$ в $m$ $
    forall xi: xi in M " и " xi in.not phi(X): forall xi^' in phi(x): m = xi + (-xi^') +  xi^'
  $
  - $
    forall x in U: sum_(i = 1)^n m_i x_i = 0
  $
  - Таким образом, мы можем заменить строку из СЛАУ, на другую строку не присутствующую в данной СЛАУ, если такая существует. 
  - Расмотрим добавление вектора $xi: xi in.not M$. По определению M
  $
    forall l in phi(X): exists.not x in U: sum_(i=  1)^n (xi_i + l_i) x_i = 0
  $
  - Рассмотрим удаление строки из СЛАУ \
    Пусть $exists {P_i (x_1 ... x_n)}^n_(i=1)$ и $U$, такие что $exists x in.not U: forall i in [1; n - 1]: P_i (x) = 0 " и " P_n (x) eq.not 0 =>$\
     если мы удалим из СЛАУ последний полином, то множество решений изменится $=>$ инвариантность не сохраняется.
  #v(1cm)
  



+
  $
    a^((k))_(i j) = a^((0))_(i j) - sum_(l = 1)^(k - 1) a^((l - 1))_(l j) (a^((l-1))_(i 1)) / (a_(l l)^((l - 1)))
  $
  #v(1cm)

+  Докажем, что $ L tilde.equiv M "iff" |dim L| = |dim M| "(где" L"," M" - линейные пространства)"$ \
  - $arrow$  \

    - Пусть $phi$ - изоморфизм #h(1cm) $beta(L) = {e_i}^n_(i=1), beta(M) = {e_i^(')}^m_(i=1)$ - базисы
    - Изоморфизм сохраняет все свойства, формулируемые в терминах линейных комбинаций $=>$ базис переходит в базис
    - Вследствии биективности $phi$: $|beta(L)| = |phi(beta(L))|= |beta(M)|$ \

  - $arrow.l$
    - Определим биекцию $sigma: beta(L) arrow beta(M)$
    - Определим линейное отображение $phi: L arrow M$, так что 
    $ phi(l) = sum_(i) a_i sigma(e_i),  $
    - $ phi(L) = phi("span"(beta(L))) = "span"(phi(beta(L))) = "span"(sigma(beta(L))) = "span"(beta(M)) = M$
    - $phi$ - изоморфизм, так как разложение по базису единственно, а $sigma$ - биективно
  + $n eq.not oo$ \
    - Базис $KK [x]$ - многочленов не выше $n$, множество
    $ beta = {x^i}_(i=0)^n $ 
    $ |beta| = n + 1 $
    - Базис $KK^* [x]$
      $ beta^* = {f^i}_(i=0)^(n): f^i (x_k) = delta_(i k) $
    - Очевидно $|beta| = |beta^*| => KK [x] tilde.equiv KK^* [x]$
    
  + $n eq oo$
    - По определению базис $KK [x]$ - счетен, так как $exists f: f(x^i) = i + 1$
    - По определению любые $p(x), xi (x) in KK [x]$ представимы в виде 
     суммы $p(x) = alpha_1 + alpha_2 x + alpha_3 x^2 + ... $ и $xi(x) = beta_1 + beta_2 x + beta_3 x^2 + ...$, где отличны от 
     нуля лишь элементы $bold("конечных")$ множеств ${alpha_1, alpha_2 ... alpha_m}$ и ${beta_1, beta_2, ... beta_l}$
    - Таким образом мы можем построить изоморфизм между $KK [x]$ и множеством функционалов \
    $ P = {f_p(x) | f_p(x) (xi(x)) = sum_(i = 1)^(max {m, l}) alpha_i beta_i #h(0.5cm) p(x), xi(x) in KK [x]} $
    - По определению $|P| = |KK [x]|$ и $P subset.eq KK^* [x]$
    - Рассмотрим функционал $g: g(p(x)) = sum_(i = 1)^oo b_i alpha_i$, то есть функционал, который представим $bold("бесконечной")$ последовательностью $b_i$. 
    - $forall p(x) in KK [x] : g(p(x)) eq.not oo$, так как коффиценты любого полинома с какого-то моменты равны нулю,
     значит сумма конечна.
    - $g in.not P$ так как любой функционал из $P$ представим как конечная последовательность коэффициентов. $g in KK^* [x]$ по определению $=> P subset KK^* [x] => |P| < |KK^* [x]| => |KK [x]| < |KK^* [x]| =>$ невозможно установить изоморфизм. 
    #v(1cm)
+ 
  - Определим $f_((a, b))((c, d)) = (a, b) dot (c, d)$
  - Покажем линейность: $forall x, y in CC: x dot y in CC$
  - $ &f_((a, b))(alpha (c, d)) = f_((a, b))( (alpha c, alpha d))= (a, b) dot (alpha c, alpha d) = \
   &= (alpha a c - alpha b d, alpha b c + alpha a d) = alpha (a c - b d, b c + a d) = alpha f_((a, b))( (c, d)) $
  - $ &f_((a, b)) ((c_1, d_1) + (c_2 , d_2)) = (a, b) dot (c_1 + c_2, d_1 + d_2) = \
    &= (a (c_1 + c_2) - b (d_1 + d_2), b (c_1 + c_2) + a (d_1 + d_2)) = \
    &= (a c_1 - b d_1, b c_1 + a d_1) + (a c_2 - b d_2, b c_2 + a d_2) = \
    &= f_((a, b)) ((c_1, d_1)) + f_((a, b)) ((c_2, d_2)) $
  - Матрица оператора:
    $ mat(
      a, -b;
      b, a;) dot mat(c; d;) = mat(a c - b d; a d + b c;)   $
  - Смысл оператора: так как $r_1 e^(i alpha_1) dot r_2 e^(i alpha_2) = r_1 r_2 e^(i
   (alpha_1 + alpha_2))$, то умножая на комплексное число $(a, b)$мы увеличиваем норму числа $(c, d)$ на норму $(a, b)$, а потом поворачиваем вектор отвечающий числу $(c, d)$ на угол вектора, который отвечает числу $(a,b)$
  #v(1cm)

+ 
  - $S O (n)$ - это множество поворотов векторов в пространстве $RR^n$ (поворот, есть преобразование, которое сохраняет длину вектора). 
  - Любой поворот задается осью вращения (двумерной плоскостью) и углом поворота 
  - В n-мерном пространстве существует $mat(n;2)$ независимых (попарно-ортогональных) плоскостей 
  - Если мы выбрали плоскость поворота, то любый поворот задается одним базовым умноженным на константу
  - $dim S O (n) = (n (n-1))/2$
  
   

+ 
  - Матрица, однозначно задающая $g_(mu nu)$ в базисе ${e_1, e_2}$ выглядит так :
    A = $
      mat(
        1, 0;
        0, 1;
      )
    $
  - Найдем выражение вектора $e_1^'$ в базисе ${e_1, e_2}$. Для этого найдем проекцию $e_1^'$ на ${e_1, e_2}$
  $
    &op("proj",
     limits: #false)_(e_1) e_1^' = cos (pi/3 - pi/6) ||e_1^'||  (e_1/(||e_1||)) = cos (pi/6) ||e_1^'|| e_1 = sqrt(3)/2 e_1\
    &op("proj",
     limits: #false)_(e_2) e_1^' = sin (pi/3 - pi/6) ||e_1^'||  (e_2/(||e_2||)) = sin (pi/6) ||e_1^'|| e_2 = 1/2 e_2
  $
  $
    e_1^' = sqrt(3)/2 e_1 + 1/2 e_2
  $

  - Аналогично найдем проекцию $e_2^'$ на ${e_1, e_2}$ 
  $
    &op("proj",
     limits: #false)_(e_1) e_2^' = cos (pi/3) ||e_2^'||  (e_1/(||e_1||)) = cos (pi/3) ||e_2^'|| e_1 = 1/2 e_1\
    &op("proj",
     limits: #false)_(e_2) e_2^' = sin (pi/3) ||e_2^'||  (e_2/(||e_2||)) = sin (pi/3) ||e_2^'|| e_2 = sqrt(3)/2 e_2
  $
  $
    e_2^' = 1/2 e_1 + sqrt(3)/2 e_2
  $

  - Найдем матрицу перехода от базиса ${e_1, e_2}$ к ${e_1^', e_2^'}$
  $
    B = mat(
      sqrt(3)/2, 1/2; 
      1/2, sqrt(3)/2 
    ) #h(1cm) 
    B^(-1) = mat(
      sqrt(3), -1;
      -1, sqrt(3);
    )
  $ 

  - В старом базисе $g_(mu nu) a^(mu) b^(nu) = a^T dot A dot b$
  - В новом базисе $B^(-1) dot x = x^' => x = B dot x^' => g_(mu nu) a^(mu) b^(nu) = a^T dot B^T dot A dot B dot b => $ матрица соответствующая $g^'_(mu nu) $
  $
    A^' = B^T dot A dot B = B dot A dot B = mat(1, sqrt(3)/2; sqrt(3)/2, 1)
  $
  - Чтобы найти третью точку для построения окружности в новом базисе решим уравнение
  $
    g_(mu nu) (alpha e_1^' + e_2^', alpha e_1^' + e_2^') = 1 \
    alpha^2 (g_(mu nu) (e_1^', e_1^') + g_(mu nu) (e_2^', e_2^') + 2 dot g_(mu nu) (e_1^', e_2^')) = 1 \ 
    alpha^2 (2 + sqrt(3)) = 1 => alpha = sqrt(1/(2+sqrt(3)))
  $
  - Найдем координаты вектора $v^' = mat(alpha; 1)$ в старом базисе 
  $
    v = B dot v^' =  mat(
      sqrt(3)/2, 1/2; 
      1/2, sqrt(3)/2 
    ) dot mat(alpha; 1) approx mat(0.94; 1.12) 
    
  $
 


= Дополнительные задачи

#set enum(numbering: "1)")

+ 
  - Докажем универсальное с-во свободной абелевой группы G с базисом $A = {a_1 ... a_n}$:
    Определим искомый гоморфизм как: 
  $
    hat(phi.alt)(x in G) = hat(phi.alt) (sum_i n_i a_i) = sum_i n_i hat(phi.alt)(a_i) = sum_i n_i phi.alt(a_i) 
    #h(0.5cm) n_i in ZZ
  $ 
  - Докажем с-во гомоморфизма:
    $
      x + y = sum_i n_i a_i + sum_i m_i a_i = sum_i (n_i + m_i) a_i \
      hat(phi.alt) (x + y) = sum_i (n_i + m_i) phi.alt (a_i) = sum_i n_i phi.alt (a_i) + 
      sum_i m_i phi.alt (a_i) = hat(phi.alt) (x) + hat(phi.alt) (y)
    $
  - Пусть существует другой гомоморфизм $phi: G arrow H$. По условию он является 
    продолжением $phi.alt$ на $G => forall i: phi(a_i) = phi.alt(a_i) = hat(phi.alt) (a_i)
    $. Но так как любое отображение $f: G arrow H$ однозначно задается значениями на ${a_1 ... a_n}$, то $phi = hat(phi.alt)$
    #image("comm_diag.png")

 
  - Пусть универсальное свойство выполняется, тогда $
  exists ! hat(phi.alt) " и " exists 
    sum_i n_i in.not ZZ: hat(phi.alt) (sum_i n_i a_i) = sum_i n_i phi.alt (a_i)
    $ 
  - Но в $H$ не 
    существует элемента, который можно представить нецелым набором коэффициентов (в группе 
    есть только сложение, а при сложении любых двух элементов группы с целыми 
    коэффициентами получается элемент с целыми коэффициентами) $=>$ противоречие
    #v(2cm)
+ 
  - Докажем, что любое преобразование$f in P S L(2, CC)$ не являющееся тождественным, фиксирует не более 2-х точек.
  $
    (a z + b)/ (c z + d) = z  \
     c z^2 + (d - a) z - b = 0
  $
  - Случай 1: $c eq.not 0$. Тогда полином от $z$ (выше) имеет 1 или 2 решения (основная теорема алгебры). $z = oo$ не является фиксированной точкой, так как $f(oo) = a/c$
  - Случай 2: $c eq 0$.
    $
   (d - a) z - b = 0   
    $
    - Случай 2.1: $a = d$ и $b = 0$ приводит к тожедественному преобразованию (не
    подходит)
    - Случай 2.2: $a = d$ и $b eq.not 0 => $ нет корней 
    - Случай 2.3: $a eq.not d => z = b/(a - d)$
  - Для точек $(x_1, x_2, x_3)$ определим $g in P S L (2, CC):$
    $
      g(z) = (z - x_1)/(z - x_3) dot (x_2 - x_3)/(z - x_1)
    $
  - Прямой проверкой убеждаемся, что $g(x_1) = 0$ и $g(x_2) = 1$ и $g(x_3) = oo$
  - Докажем единственность $g$: пусть существует $p in P S L (2, CC): p eq.not g$, которое переводит точки $(x_1, x_2, x_3)$ в $(0, 1, oo)$. Тогда:
    - $(g^(-1) circle.small p) in P S L (2, CC)$ фиксирует точки $(x_1, x_2, x_3)$, но из доказанного выше следует, что любое преобразование из $P S L (2, CC)$ фиксирующее более 2 точек является тождественным $=> g = p$
    - Аналогичное док-во для $(p circle.small g^(-1))$
  - Любое $f in P S L (2, CC)$ однозначно задается $x in CC^4 => P S L (2, CC) tilde.equiv CC^4 => P S L (2, CC) tilde.equiv.not CC^3$
+ 
  - Пусть $B$ - билинейное симметричное скалярное произведение.
  - $ 
    forall l, m in L: l eq.not m:  B(l + m, l + m) &= B(l, l + m) + B(m, l + m) = \
                                      &= B(l, l) + B(l, m) + B(m, l) + B(m, m) = \
                                      &= 2B(l, m) + B(l, l) + B(m, m) =>
  $
  - $
    => B(l, m) &= (B(l + m, l + m) - B(l, l) - B(m, m)) / 2 = \
              &= (Q(l + m) - Q(l) - Q(m)) / 2
  $

  - $
    l eq m: B(l, l) = (B(2l, 2l) - 2B(l, l)) / 2 = (4Q(l) - 2Q(l)) / 2 = Q(l)
  $
  
